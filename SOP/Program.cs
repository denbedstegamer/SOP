// Imports
using System;
using static System.Console;
using System.Text;
using System.IO;
using System.Security.Cryptography;

// The main class
class main
{
    // The Main function of the program
    static void Main(string[] args)
    {
        // Decleration of the variables used by Person1 and Person2
        Byte[] Person1PublicKey;
        Byte[] Person2PublicKey;
        Byte[] Person1SharedKey;
        Byte[] Person2SharedKey;

        // Initialization of the Keysize for both the public and private keys
        int keySize = 521;

        // Sets the secret message that is going to be encrypted and decrypted by respectively Person1 and Person2
        String secretMessage = "The secret message";

        // Creates a CNG (Cryptography Next Genration) implimentiation of the ECDH (Elliptic Curve Diffie-Hellman) algorithm for Person1 with a randomly generated keyPair consisting of both a public and a private key
        using (ECDiffieHellmanCng ECDHCNGForPerson1 = new ECDiffieHellmanCng(keySize))
        {
            // Sets the method used for deriving the different shared keys as an ECDH-hash-function
            ECDHCNGForPerson1.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;

            // Sets the hashing algorithm used as the Sha256 algorithm
            ECDHCNGForPerson1.HashAlgorithm = CngAlgorithm.Sha256;

            // Sets Person1s public key as the public key generated by the ECDHCNG for Person1
            Person1PublicKey = ECDHCNGForPerson1.PublicKey.ToByteArray();

            // Prints the contents of Person1s public key
            Write("Person 1s public key is: " + Environment.NewLine);
            foreach (Byte b in Person1PublicKey)
            {
                Write($"{b} ");
            }
            Write(Environment.NewLine + Environment.NewLine);

            // Creates a CNG (Cryptography Next Genration) implimentiation of the ECDH (Elliptic Curve Diffie-Hellman) algorithm for Person2 with a randomly generated keyPair consisting of both a public and a private key
            using (ECDiffieHellmanCng ECDHCNGForPerson2 = new ECDiffieHellmanCng(keySize))
            {
                // Sets the method used for deriving the different shared keys as an ECDH-hash-function
                ECDHCNGForPerson2.KeyDerivationFunction = ECDiffieHellmanKeyDerivationFunction.Hash;

                // Sets the hashing algorithm used as the Sha256 algorithm
                ECDHCNGForPerson2.HashAlgorithm = CngAlgorithm.Sha256;

                // Sets Person2s public key as the public key generated by the ECDHCNG for Person2
                Person2PublicKey = ECDHCNGForPerson2.PublicKey.ToByteArray();

                // Prints the contents of Person2s public key
                Write("Person 2s public key is: " + Environment.NewLine);
                foreach (Byte b in Person2PublicKey)
                {
                    Write($"{b} ");
                }
                Write(Environment.NewLine + Environment.NewLine);

                // Sets the key used for deriving the shared key to the contents of Person1s public key, and this is used by Person1
                CngKey k2 = CngKey.Import(Person1PublicKey, CngKeyBlobFormat.EccPublicBlob);

                // Creates the shared key that Person2 uses to the shared key derived from a key exchange
                Person2SharedKey = ECDHCNGForPerson2.DeriveKeyMaterial(k2);
            }

            // Sets the key used for deriving the shared key to the contents of Person2s public key, and this is used by Person1
            CngKey k1 = CngKey.Import(Person2PublicKey, CngKeyBlobFormat.EccPublicBlob);

            // Creates the shared key that Person1 uses to the shared key derived from a key exchange
            Person1SharedKey = ECDHCNGForPerson1.DeriveKeyMaterial(k1);

            // Prints the contents of both shared keys
            Write("Person 1s shared key is: " + Environment.NewLine);
            foreach (Byte b in Person1SharedKey)
            {
                Write($"{b} ");
            }
            Write(Environment.NewLine + Environment.NewLine);

            Write("Person 2s shared key is: " + Environment.NewLine);
            foreach (Byte b in Person2SharedKey)
            {
                Write($"{b} ");
            }
            Write(Environment.NewLine + Environment.NewLine);

            // Sends the secret message from Person1 using Person1s shared key to Person2
            Send(Person1SharedKey, secretMessage, out Byte[] encryptedMessage, out Byte[] IV);

            // Recieves the secret message sent by Person1 using Person2s shared key
            Receive(Person2SharedKey, encryptedMessage, IV, out String decryptedMessage);

            // Prints the contents of the decrypted message
            Write(decryptedMessage);

            // Acts as a buffer so you can see the output in the console before the program is terminated
            ReadKey();
        }
    }

    // Method used for sending a message encrypted, in this example used by Person1
    public static void Send(Byte[] key, string secretMessage, out Byte[] encryptedMessage, out Byte[] IV)
    {
        // Initializes the standard used for encryption, here is used the AES (Advanced Encryption Standard)
        using (Aes aes = new AesCryptoServiceProvider())
        {
            // Sets the key used for the encryption as the shared key that Person1 has derived
            aes.Key = key;

            // Sets the initialization vector
            IV = aes.IV;

            // Creates the MemoryStream that is going to store the encrypted message
            using (MemoryStream ms = new MemoryStream())
            {
                // Creates the CryptoStream that is going encrypt the message
                using (CryptoStream cs = new CryptoStream(ms, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    // Turns the secret message into a standardized version that can be used by the CryptoStream
                    Byte[] plainTextMessage = Encoding.UTF8.GetBytes(secretMessage);

                    // Writes the plain text message to the CryptoStream
                    cs.Write(plainTextMessage, 0, plainTextMessage.Length);

                    // Closes the stream so no more data can be written to it, and releases all recources asociated with the stream
                    cs.Close();

                    // Sets the encrypted message to the contents of the MemoryStream
                    encryptedMessage = ms.ToArray();
                }
            }
        }
    }

    // Method used for decrypting a recieved message, in this example used by Person2
    public static void Receive(Byte[] key, Byte[] encryptedMessage, Byte[] IV, out String decryptedMessage)
    {
        // Initializes the standard used for encryption, here is used the AES (Advanced Encryption Standard)
        using (Aes aes = new AesCryptoServiceProvider())
        {
            // Sets the key used for the decryption as the shared key that Person2 has derived
            aes.Key = key;

            // Sets the initialization vector
            aes.IV = IV;

            // Creates the MemoryStream that is going to store the message for the CryptoStream
            using (MemoryStream ms = new MemoryStream())
            {
                // Creates the CryptoStream that is going decrypt the message
                using (CryptoStream cs = new CryptoStream(ms, aes.CreateDecryptor(), CryptoStreamMode.Write))
                {
                    // Writes the encrypted message to the CryptoStream
                    cs.Write(encryptedMessage, 0, encryptedMessage.Length);

                    // Closes the stream so no more data can be written to it, and releases all recources asociated with the stream
                    cs.Close();

                    // Turns the MemoryStream into readable text in the form of a String
                    decryptedMessage = Encoding.UTF8.GetString(ms.ToArray());
                }
            }
        }
    }
}